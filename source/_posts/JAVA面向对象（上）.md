---
title: 'JAVA面向对象（上）'
date: 2021-04-23 21:06:54
tags:
	- JAVA
	- JAVA基础
---
# 一、类与对象
## 1.面向对象学习的三条主线：

> 1.Java类及类的成员：属性、方法、构造器；代码块、内部类
> 2.面向对象的大特征：**封装性、继承性、多态性、(抽象性)**
> 3.其它关键字：this、super、static、final、abstract、interface、package、import等

> “**大处着眼，小处着手**”


<!-- more -->

## 2.面向对象与面向过程（理解）
> 1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。
> 2.面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

**举例对比：人把大象装进冰箱。**

* 1.**面向过程：**强调的是功能行为，以函数为最小单位，考虑怎么做。

	① 把冰箱门打开
	② 抬起大象，塞进冰箱
	② 把冰箱门关闭


 * 2.**面向对象：**强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。


	人{
		打开(冰箱){
			冰箱.开开();
		}

		抬起(大象){
			大象.进入(冰箱);
		}

		关闭(冰箱){
			冰箱.闭合();
		}

	}

	冰箱{
		开开(){}
		闭合(){}
	}

	大象{
		进入(冰箱){
		}
	}

## 3.完成一个项目（或功能）的思路：

> 1. 根据问题需要，选择问题所针对的现实世界中的实体。
> 2. 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。
> 3. 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
> 4. 将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。


## 4.面向对象中两个重要的概念：

**类：**对一类事物的描述，是抽象的、概念上的定义
**对象：**是实际存在的该类事物的每个个体，因而也称为实例(instance)
  >面向对象程序设计的重点是类的设计
  >设计类，就是设计类的成员。

**二者的关系：**
  >对象，是由类new出来的，派生出来的。

## 5.面向对象思想落地实现的规则一
  >1.创建类，设计类的成员
  >2.创建类的对象
  >3.通过“对象.属性”或“对象.方法”调用对象的结构

补充：几个概念的使用说明
  >属性 = 成员变量 = field = 域、字段
  >方法 = 成员方法 = 函数 = method
  >创建类的对象 = 类的实例化 = 实例化类

## 6.对象的创建与对象的内存解析

**典型代码：**

	Person p1 = new Person();
	Person p2 = new Person();
	Person p3 = p1;//没有新创建一个对象，共用一个堆空间中的对象实体。

**说明：**
>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）
>意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。


## 7.匿名对象

>我们创建的对象，没显式的赋给一个变量名。即为匿名对象

**举例：**

	new Phone().sendEmail();
	new Phone().playGame();
		
	new Phone().price = 1999;
	new Phone().showPrice();//0.0

**应用场景：**

	PhoneMall mall = new PhoneMall();
	
	//匿名对象的使用
	mall.show(new Phone());
	其中，
	class PhoneMall{
		public void show(Phone phone){
			phone.sendEmail();
			phone.playGame();
		}
	}

## 8.理解"万事万物皆对象"  *

1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构

>Scanner,String等
>文件：File
>网络资源：URL

2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。


**例题：**
>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。
>问题一：打印出3年级(state值为3）的学生信息。
>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息

	class Student_Test{
		public static void main(String[] args){
			Student_Test student = new Student_Test();
			Student[] Stu = new Student[20];
			Stu = student.Initi();//学生信息初始化
			student.print(Stu);//打印学生信息
			int id = 4;//选中一个学号
			student.print(Stu, id);//打印固定学号的学生信息
			student.Sort(Stu);//学生按照成绩从高到底排序
			student.print(Stu);//再打印学生信息
		}
		/**
		 * 初始化学生信息
		 */
		public Student[] Initi(){
			Student[] Stu = new Student[20];
			for(int i = 0; i < 20; i++){
				Stu[i] = new Student();
				Stu[i].number = i + 1;
				Stu[i].state = (int)(Math.random() * 6 + 1);
				Stu[i].score = (int)(Math.random() * 101);
			}
			return Stu;
		}
		void Sort(Student[] Stu){
			System.out.println("成绩排序：");
			for(int i = 0; i < 20; i++){
				for(int j = 0; j < 20 - i - 1; j++){
					if(Stu[j].score < Stu[j + 1].score){
						Student temp = new Student();
						temp = Stu[j];
						Stu[j] = Stu[j + 1];
						Stu[j + 1] = temp;
					}
				}
			}
		}
		void print(Student[] Stu){
			for(int i = 0; i < 20; i++){
				System.out.println("学号：" + Stu[i].number + " 年级：" 
				+ Stu[i].state + " 分数：" + Stu[i].score + "\n");
			}
		}
		void print(Student[] Stu, int t){
			for(int i = 0; i < 20; i++){
				if(Stu[i].state == t)
					System.out.println("学号：" + Stu[i].number + " 年级：" 
					+ Stu[i].state + " 分数：" + Stu[i].score + "\n");
				}
		}
	}
	public class Student {
		int number;
		int state;
		int score;
	}

# 二、类的构造

## 1.属性
### 属性和局部变量：
**相同点：**
>1. 定义变量的格式：数据类型  变量名 = 变量值
>2. 先声明，后使用
>3. 变量都有其对应的作用域 


不同点|类中声明位置|权限修饰符|默认初始化值|内存中加载位置
:--:|:--:|:--:|:--:|:--:|
属性|直接定义在类的一对{}内|**（1）**可以在声明属性时，指明其权限，使用权限修饰符。**（2）**常用的权限修饰符：private、public、缺省、protected  --->封装性**（3）**目前，大家声明属性时，都使用缺省就可以了。|类的属性，根据其类型，都默认初始化值。（1）整型（byte、short、int、long：0）（2）浮点型（float、double：0.0）（3）字符型（char：0  （或'\u0000'））（4）布尔型（boolean：false）（5）引用数据类型（类、数组、接口：null）|**加载到堆空间中   （非static）**
局部变量|声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量|不可以使用权限修饰符。|**没默认初始化值。**意味着，我们在调用局部变量之前，一定要显式赋值。**特别地：**形参在调用时，我们赋值即可。|加载到**栈空间**


## 2.方法
描述类应该具的功能。

**比如：**

	Math类：sqrt()\random()
	Scanner类：nextXxx()
	Arrays类：sort() \ binarySearch() \ toString() \ equals() 
 ### (1)举例：

	public void eat(){}
	public void sleep(int hour){}
	public String getName(){}
	public String getNation(String nation){}

 ### (2)方法的声明：
	权限修饰符  返回值类型  方法名(形参列表){
		方法体
	}
**注意：**static、final、abstract 来修饰的方法。
## 3.return关键字

>1. 使用范围：使用在方法体中
>2. 作用：
>① 结束方法
>② 针对于返回值类型的方法，使用"return 数据"方法返回所要的数据。
>3. 注意点：return关键字后面不可以声明执行语句。


## 4.方法的重载

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。


**总结：**
>"**两同**": 同一个类、相同方法名
>"**一不同**": 参数列表不同(参数个数不同，参数类型不同)


## 5.可变个数形参的方法*

### (1)使用说明：
>1.jdk 5.0新增的内容
>2.具体使用：
>*   2.1 可变个数形参的格式：数据类型 ... 变量名
>*   2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个,1个,2个，。。。
>*   2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
>*   2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。
>*   2.5 可变个数形参在方法的形参中，必须声明在末尾
>* 	 2.6  可变个数形参在方法的形参中,最多只能声明一个可变形参。

### (2)举例说明：*

**写法一：**

	public void show(String ... strs){
	}

**写法二：**

	public void show(String[] strs){
	}

**调用时：**

	test.show(new String[]{"AA","BB","CC"});//写法一
	test.show("AA","BB","CC");//写法二

## 6.java值传递机制

### (1)规则
>如果变量是**基本数据类型**，此时赋值的是变量所保存的**数据值**。
>如果变量是**引用数据类型**，此时赋值的是变量所保存的数据的**地址值**。


### (2)针对于方法的参数概念
>形参：方法定义时，声明的小括号内的参数
>实参：方法调用时，实际传递给形参的数据


## 7.递归方法
### (1)定义：
递归方法：一个方法体内调用它自身。
### (2)如何理解递归方法？
> 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
> 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。


### (3)举例：
**例1：计算1-n之间所自然数的和**

	public int getSum(int n) {
		if (n == 1) {
			return 1;
		} else {
			return n + getSum(n - 1);
		}
	}

**例2：计算1-n之间所自然数的乘积:n!**

	public int getSum1(int n) {

		if (n == 1) {
			return 1;
		} else {
			return n * getSum1(n - 1);
		}
	}
	
**例3：已知一个数列：f(0) = 1,f(1) = 4,f(n + 2) = 2 * f(n + 1) + f(n),其中n是大于0的整数，求f(10)的值。**

	public int f(int n){
		if(n == 0){
			return 1;
		}else if(n == 1){
			return 4;
		}else{
			return 2*f(n - 1) + f(n - 2);
		}
	}

**例4：斐波那契数列**
	
**例5：汉诺塔问题**
	
**例6：快排**

# 三、构造器（或构造方法）：Constructor
## 1.构造器的作用：
>1. 创建对象
>2. 初始化对象的信息


## 2.使用说明：
>1. 如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器
>2. 定义构造器的格式：权限修饰符  类名(形参列表){}
>3. 一个类中定义的多个构造器，彼此构成重载
>4. 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
>5. 一个类中，至少会有一个构造器。


## 3.举例：
//构造器

	public Person(){
		System.out.println("Person().....");
	}
	
	public Person(String n){
		name = n;
		
	}
	
	public Person(String n,int a){
		name = n;
		age = a;
	}
## 4.属性赋值的先后顺序
>1. 默认初始化
>2. 显式初始化
>3. 构造器中初始化
>4. 通过"对象.方法" 或 "对象.属性"的方式，赋值


以上操作的先后顺序：① - ② - ③ - ④  
## 5.JavaBean
指符合如下标准的Java类：
>类是公共的
>一个无参的公共的构造器
>属性，且对应的get、set方法


# 四、关键字：this
## 1.可以调用的结构：属性、方法；构造器
## 2.this调用属性、方法：
**this理解：**
当前对象 或 当前正在创建的对象

>1. 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
>2. 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。


## 3.this调用构造器：
>1. 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器
>2. 构造器中不能通过"this(形参列表)"方式调用自己
>3. 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
>4. 规定："this(形参列表)"必须声明在当前构造器的首行
>5. 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器


# 五、关键字：package/import

## 1.package的使用

>1. 为了更好的实现项目中类的管理，提供包的概念
>2. 使用package声明类或接口所属的包，声明在源文件的首行
>3. 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”
>4. 每"."一次，就代表一层文件目录。

## 2.JDK中的主要包介绍

Java中常用的包|说明
:--:|:--:
java.lang|包含一些Java语言的核心类，如String, Math, Iteger, System和thread，提供常用核心功能
java.net|包含执行与网络相关的操作的类
java.io|包换能提供多种输入\输出功能的类
java.util|包含一些实用工具类，如定义系统特性、实用日期、日历相关的函数
java.text|包含了一些java格式化相关的类
java.sql|包含了java金星JDBC数据库编程的相关类/接口
java.awt|包含了构成抽象窗口工具集（abstract, window, toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）

## 3.MVC设计模式
**模型层  model  主要处理数据：**
>数据对象封装 model.bean/domain
>数据库操作类 model.dao
>数据库 model.db

**控制层  controller  处理业务逻辑**
>应用界面相关 controller.activity
>存放fragment controller.fragment
>显示列表的适配器 controller.adapter
>服务相关的 controller.service
>抽取的基类 controller.base


**视图层  view  显示数据**
>相关工具类 view.utils
>自定义view view.ui


## 4.import的使用
**import:导入**
>1. 在源文件中显式的使用import结构导入指定包下的类、接口
>2. 声明在包的声明和类的声明之间
>3. 如果需要导入多个结构，则并列写出即可
>4. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所结构
>5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
>6. 如果使用的类或接口是本包下定义的，则可以省略import结构
>7. 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。
>8. 使用"xxx.*"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
>9. import static:导入指定类或接口中的静态结构:属性或方法。