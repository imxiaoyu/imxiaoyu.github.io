---
title: 'JAVA面向对象（中）'
date: 2021-04-24 21:06:54
tags:
	- JAVA
	- JAVA基础
---
# 一、方法的重写
## 1.什么是方法的重写(override 或 overwrite)？
子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。
<!-- more -->

## 2.应用
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。
## 3.举例
	class Circle{
		public double findArea(){}//求面积
	}
	class Cylinder extends Circle{
		public double findArea(){}//求表面积
	}

	class Account{
		public boolean withdraw(double amt){}
	}
	class CheckAccount extends Account{
		public boolean withdraw(double amt){}
	}


## 4.重写的规则
	方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
		//方法体
	}
>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
>特殊情况：子类不能重写父类中声明为private权限的方法
③ 返回值类型：
>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。	


## 5.面试题
### 区分方法的重写和重载？

**二者的概念：**
>1.重载和重写的具体规则
>重载：不表现为多态性。
>重写：表现为多态性。
>2.重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
>3.对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为**“早绑定”或“静态绑定”**；
>4.对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为**“晚绑定”或“动态绑定”**。 
>**引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”**


# 二、关键字:super

## 1.super 关键字可以理解为：父类的
## 2.可以用来调用的结构
属性、方法、构造器
## 3.super调用属性、方法
>1.我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
>2.特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
>3.特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。


## 4.super调用构造器
>1.我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
>2."super(形参列表)"的使用，必须声明在子类构造器的首行！
>3.我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
>4.在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
>5.在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器


# 三、子类对象实例化全过程

## 1.从结果上看：继承性
> 子类继承父类以后，就获取了父类中声明的属性或方法。
> 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。


## 2.从过程上看
>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。

## 3.强调说明
>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。


# 四、Objet类的使用

## 1.java.lang.Object类的说明
>1.Object类是所Java类的根父类
>2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 
>3.Object类中的功能(属性、方法)就具通用性。
>① 属性：无
>② 方法：equals() / toString() / getClass() /hashCode() / clone() / finalize() wait() 、 notify()、notifyAll()
>4.Object类只声明了一个空参的构造器


## 2.equals()方法
### (1)equals()的使用
>1.是一个方法，而非运算符
>2.只能适用于引用数据类型
>3.Object类中equals()的定义：


	public boolean equals(Object obj) {
		return (this == obj);
	}

**说明：**
Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体



>4.像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。
>5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.
>重写的原则：比较两个对象的实体内容是否相同.


### (2)如何重写equals()
**手动重写举例：**

	class User{
	String name;
	int age;
		//重写其equals()方法
		public boolean equals(Object obj){
			if(obj == this){
				return true;
			}
			if(obj instanceof User){
				User u = (User)obj;
				return this.age == u.age && this.name.equals(u.name);
			}
			return false;
		}
	}

**开发中如何实现：自动生成的**
### (3)回顾 == 运算符的使用
>== ：运算符
>1.可以使用在基本数据类型变量和引用数据类型变量中
>2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
>补充： == 符号使用时，必须保证符号左右两边的变量类型一致。


## 3.toString()方法
### (1)toString()的使用
>1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
>2.Object类中toString()的定义：


	public String toString() {
		return getClass().getName() + "@" + Integer.toHexString(hashCode());
	}

>3.像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回"实体内容"信息
>4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"


### (2)如何重写toString()
**举例(eclipse可以自动实现)：**



	@Override
	public String toString() {
		return "Customer [name=" + name + ", age=" + age + "]";
	}

## 4.面试题
>**① final、finally、finalize的区别？**
>**②  == 和 equals() 区别**

# 四、单元测试方法
**Java中的JUnit单元测试**
>**步骤：**
>1.中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步
>2.创建Java类，进行单元测试。
>此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器
>3.此类中声明单元测试方法。
>此时的单元测试方法：方法的权限是public,没返回值，没形参
>4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;
>5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。
>6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test
>**说明：**
>1.如果执行结果没任何异常：绿条
>2.如果执行结果出现异常：红条



# 五、包装类的使用
## 1.为什么要有包装类(或封装类）
为了使基本数据类型的变量具有类的特征，引入包装类。

## 2.基本数据类型与对应的包装类*

基本数据类型|包装类|包装类的父类
:--:|:--:|:--:
byte|Byte|Number
short|Short|Number
**int**|**Integer**|Number
long|Long|Number
float|Float|Number
double|Double|Number
boolean|Boolean
**char**|**Character**


## 3.需要掌握的类型间的转换：（基本数据类型、包装类、String）

>**简易版：**
>1.**基本数据类型<--->包装类**：JDK 5.0 新特性：自动装箱 与自动拆箱
>2.**基本数据类型、包装类--->String**:调用String重载的valueOf(Xxx xxx)
>3.**String--->基本数据类型、包装类:**调用包装类的parseXxx(String s)
>**注意：**转换时，可能会报NumberFormatException
>**应用场景举例：**
>Vector类中关于添加元素，只定义了形参为Object类型的方法：
>v.addElement(Object obj);   //基本数据类型 --->包装类 --->使用多态

