---
title: 'JAVA面向对象——封装、继承、多态'
date: 2021-04-24 21:06:54
tags:
	- JAVA
	- JAVA基础
---

# 一、面向对象的特征：封装性

## 1.为什么要引入封装性？
>我们程序设计追求“**高内聚，低耦合**”。
>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；
>低耦合 ：仅对外暴露少量的方法用于使用。


<!-- more -->
隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。

## 2.问题引入： 
>当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
>此时，针对于属性就体现了**封装性**。


## 3.封装性思想具体的代码体现：
**体现一：**将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值

	private double radius;
	public void setRadius(double radius){
		this.radius = radius;
	}
	public double getRadius(){
		return radius;
	}
**体现二：**不对外暴露的私有的方法
**体现三：**单例模式（将构造器私有化）
**体现四：**如果不希望类在包外被调用，可以将类设置为缺省的。

## 4.Java规定的四种权限修饰符
### (1)权限从小到大顺序为
>private <  缺省 < protected < public

### (2)具体的修饰范围*
修饰符|类内部|同一个包|不同包的子类|同一个工程
:--:|:--:|:--:|:--:|:--:
private|Yes
缺省|Yes|Yes
protected|Yes|Yes|Yes
public|Yes|Yes|Yes|Yes

### (3)权限修饰符可用来修饰的结构说明：
>4种权限都可以用来修饰**类的内部结构**：属性、方法、构造器、内部类
>**修饰类**的话，**只能使用：缺省、public**

# 二、面向对象的特征：继承性

## 1.为什么要有类的继承性？(继承性的好处）
> 减少了代码的冗余，提高了代码的复用性
> 便于功能的扩展
> 为之后多态性的使用，提供了前提

## 2.继承性的格式：

	class A extends B{}
	      A:子类、派生类、subclass
	      B:父类、超类、基类、superclass

## 3.子类继承父类以后有哪些不同？
### (1)体现
一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。

>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。


### (2)子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。
>子类和父类的关系，不同于子集和集合的关系。
>extends：延展、扩展


## 4.Java中继承性的说明
>1.一个类可以被多个子类继承。
>2.Java中类的单继承性：一个类只能有一个父类
>3.子父类是相对的概念。
>4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
>5.子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

## 5.java.lang.Object类的理解
>1.如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类
>2.所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类
>3.意味着，所的java类具有java.lang.Object类声明的功能。


# 三、面向对象的特征：多态性

## 1.多态性的理解：可以理解为一个事物的多种形态。
## 2.何为多态性：
**对象的多态性：**父类的引用指向子类的对象（或子类的对象赋给父类的引用）
**举例：**

	Person p = new Man();
	Object obj = new Date();
## 3.多态性的使用：虚拟方法调用
> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
> 总结：编译，看左边；运行，看右边。


## 4.多态性的使用前提：
>1.类的继承关系  
>2.方法的重写


## 5.多态性的应用举例：
**举例一：**

	public void func(Animal animal){//Animal animal = new Dog();
		animal.eat();
		animal.shout();
	}

**举例二：**

	public void method(Object obj){
	}

**举例三：**

	class Driver{
		public void doData(Connection conn){//conn = new MySQlConnection(); / conn = new OracleConnection();
		//规范的步骤去操作数据
		//conn.method1();
		//conn.method2();
		//conn.method3();
		}
	}

## 6.多态性使用的注意点：
>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

## 7.关于向上转型与向下转型：
### (1)向上转型：多态
### (2)向下转型：
**(2.1)为什么使用向下转型：**
>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。


**(2.2)如何实现向下转型：**
>使用强制类型转换符：()


**(2.3)使用时的注意点：**
>1.使用强转时，可能出现ClassCastException的异常。
>2.为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。


**(2.4)instanceof的使用：**
>1.a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。
>2.如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。
>3.要求a所属的类与类A必须是子类和父类的关系，否则编译错误。


## 8. 面试题：
### (1)谈谈你对多态性的理解？
>1.实现代码的通用性。
>2.Object类中定义的public boolean equals(Object obj){  }
JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
>3.抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）
8.2 多态是编译时行为还是运行时行为？